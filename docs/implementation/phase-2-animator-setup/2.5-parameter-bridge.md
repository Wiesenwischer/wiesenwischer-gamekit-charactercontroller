# 2.5 Parameter-Bridge

**Commit:** `feat(phase-2): 2.5 Parameter-Bridge`

---

## Ziel

Eine `AnimatorParameterBridge` Komponente erstellen, die die State Machine Daten (`PlayerStateReusableData`) mit dem Unity Animator synchronisiert. Dies ist die zentrale Brücke zwischen Gameplay-Logik und Animation.

---

## Konzept

```
┌─────────────────────┐      ┌──────────────────────┐      ┌──────────────┐
│  PlayerController    │      │ AnimatorParameterBridge│      │   Animator   │
│  ├─ StateMachine     │─────>│ (IAnimationController) │─────>│  Controller  │
│  │  ├─ ReusableData  │      │                        │      │  ├─ Speed    │
│  │  └─ CurrentState  │      │ SetSpeed(normalized)   │      │  ├─ IsGround │
│  └─ Locomotion       │      │ SetGrounded(bool)      │      │  ├─ VertVel  │
│     └─ BaseVelocity  │      │ SetVerticalVelocity()  │      │  ├─ Jump ▶   │
│                      │      │ TriggerJump()          │      │  ├─ Land ▶   │
│                      │      │ TriggerLand()          │      │  └─ HardLand │
└─────────────────────┘      └──────────────────────┘      └──────────────┘
```

Die Bridge implementiert das `IAnimationController` Interface (aus Phase 1.4) und wird jeden Frame aktualisiert.

---

## Implementation

### AnimatorParameterBridge.cs

**Datei:** `Packages/Wiesenwischer.GameKit.CharacterController.Animation/Runtime/Core/AnimatorParameterBridge.cs`

```csharp
using UnityEngine;
using Wiesenwischer.GameKit.CharacterController.Core;
using Wiesenwischer.GameKit.CharacterController.Core.Data;

namespace Wiesenwischer.GameKit.CharacterController.Animation
{
    /// <summary>
    /// Synchronisiert State Machine Daten mit dem Unity Animator.
    /// Implementiert IAnimationController für entkoppelte Kommunikation.
    /// </summary>
    [RequireComponent(typeof(Animator))]
    public class AnimatorParameterBridge : MonoBehaviour, IAnimationController
    {
        #region Serialized Fields

        [Header("References")]
        [SerializeField] private PlayerController _playerController;

        [Header("Smoothing")]
        [Tooltip("Wie schnell der Speed-Parameter sich dem Zielwert annähert.")]
        [SerializeField] private float _speedDampTime = 0.1f;

        [Tooltip("Wie schnell der VerticalVelocity-Parameter sich annähert.")]
        [SerializeField] private float _verticalVelocityDampTime = 0.05f;

        #endregion

        #region Private Fields

        private Animator _animator;

        #endregion

        #region Unity Lifecycle

        private void Awake()
        {
            _animator = GetComponent<Animator>();

            if (_playerController == null)
                _playerController = GetComponentInParent<PlayerController>();
        }

        private void LateUpdate()
        {
            if (_playerController == null || _animator == null) return;

            UpdateParameters();
        }

        #endregion

        #region Parameter Update

        /// <summary>
        /// Aktualisiert alle Animator-Parameter basierend auf dem aktuellen State.
        /// Wird in LateUpdate aufgerufen, damit alle State-Änderungen
        /// des Frames berücksichtigt werden.
        /// </summary>
        private void UpdateParameters()
        {
            var data = _playerController.StateMachine.ReusableData;
            var config = _playerController.LocomotionConfig;

            // Speed: Normalisiert auf RunSpeed (0=Idle, 0.5=Walk, 1.0=Run, 1.5=Sprint)
            float horizontalSpeed = data.HorizontalVelocity.magnitude;
            float normalizedSpeed = config.RunSpeed > 0f
                ? horizontalSpeed / config.RunSpeed
                : 0f;

            _animator.SetFloat(
                AnimationParameters.SpeedHash,
                normalizedSpeed,
                _speedDampTime,
                Time.deltaTime);

            // IsGrounded
            _animator.SetBool(AnimationParameters.IsGroundedHash, data.IsGrounded);

            // VerticalVelocity (gedämpft für sanftere Übergänge)
            _animator.SetFloat(
                AnimationParameters.VerticalVelocityHash,
                data.VerticalVelocity,
                _verticalVelocityDampTime,
                Time.deltaTime);
        }

        #endregion

        #region IAnimationController Implementation

        public void SetSpeed(float speed)
        {
            _animator.SetFloat(AnimationParameters.SpeedHash, speed);
        }

        public void SetGrounded(bool isGrounded)
        {
            _animator.SetBool(AnimationParameters.IsGroundedHash, isGrounded);
        }

        public void SetVerticalVelocity(float velocity)
        {
            _animator.SetFloat(AnimationParameters.VerticalVelocityHash, velocity);
        }

        public void TriggerJump()
        {
            _animator.SetTrigger(AnimationParameters.JumpHash);
        }

        public void TriggerLand()
        {
            _animator.SetTrigger(AnimationParameters.LandHash);
        }

        public void SetAbilityLayerWeight(float weight)
        {
            _animator.SetLayerWeight(AnimationParameters.AbilityLayerIndex, weight);
        }

        #endregion

        #region Landing

        /// <summary>
        /// Setzt den HardLanding-Parameter und triggert die Land-Animation.
        /// Sollte vom Landing-State aufgerufen werden.
        /// </summary>
        public void TriggerLanding(bool isHardLanding)
        {
            _animator.SetBool(AnimationParameters.HardLandingHash, isHardLanding);
            TriggerLand();
        }

        #endregion

        #region Status Layer

        /// <summary>
        /// Setzt das Gewicht des Status-Layers (0-1).
        /// Bei Weight=1 überschreibt der Status-Layer den gesamten Körper.
        /// Verwendet für Stun, Knockback, Death etc.
        /// </summary>
        public void SetStatusLayerWeight(float weight)
        {
            _animator.SetLayerWeight(AnimationParameters.StatusLayerIndex, weight);
        }

        #endregion
    }
}
```

---

## Erweiterbarkeit: Gameplay Tags & Priority System (AAA-Spec)

> Referenz: [AAA Action Combat Architecture](../../specs/AAA_Action_Combat_Character_Architecture.md), Sections 5+6

Die AAA-Spec beschreibt ein **Tag-basiertes System** (z.B. `State.Grounded`, `Ability.Attack`, `Status.Stunned`) und ein **Priority System** für State-Übergänge. Diese werden in späteren Phasen implementiert, aber die Bridge muss dafür erweiterbar sein.

### Wie die Bridge darauf vorbereitet ist

1. **`IAnimationController` Interface** kann um Tag-basierte Methoden erweitert werden (z.B. `SetGameplayTag(string tag, bool active)`) ohne die bestehende API zu brechen.
2. **Layer-Weight-Steuerung** (`SetAbilityLayerWeight`, `SetStatusLayerWeight`) ermöglicht es dem Priority System, Layer ein-/auszublenden.
3. **Die Bridge kennt keine States direkt** – sie reagiert nur auf Daten. Ein zukünftiges Tag/Priority System kann die gleichen Animator-Parameter setzen, ohne die Bridge umzubauen.

### Kein Over-Engineering jetzt

Die aktuelle Implementation beschränkt sich auf die tatsächlich benötigten Parameter (Speed, IsGrounded, VerticalVelocity, Jump, Land, HardLanding). Erweiterungen für Tags/Priorities erfolgen erst, wenn das Ability System (Phase 4) oder Combat (Phase 8) implementiert wird.

---

## Integration mit PlayerController

Die Bridge muss im `PlayerController` referenzierbar sein. In Phase 3 wird die vollständige Integration durchgeführt. Hier die Vorbereitung:

### Optionales Interface-Feld in PlayerController

Das `PlayerController` kann optional eine `IAnimationController`-Referenz halten. Die vollständige Verkabelung erfolgt in Phase 3 (Animation-Integration).

```csharp
// In PlayerController.cs (wird in Phase 3 hinzugefügt):
public IAnimationController AnimationController { get; private set; }
```

---

## Speed-Normalisierung im Detail

### Berechnung

```
normalizedSpeed = horizontalVelocity.magnitude / Config.RunSpeed

Beispiele mit DefaultConfig (WalkSpeed=3, RunSpeed=6):
  Idle      → 0 / 6       = 0.0
  Walk      → 3 / 6       = 0.5
  Run       → 6 / 6       = 1.0
  Sprint    → 9 / 6       = 1.5
  Decel     → 4.2 / 6     = 0.7   (zwischen Walk und Run)
```

### Warum RunSpeed als Basis?

- RunSpeed ist die "Standard"-Geschwindigkeit (Default Movement)
- WalkSpeed ist langsamer (0.5x), Sprint ist schneller (1.5x)
- Die Normalisierung sorgt dafür, dass die Blend Tree Thresholds unabhängig von Config-Werten funktionieren

### Damping

Der `_speedDampTime` von 0.1s sorgt für:
- Sanfte Übergänge zwischen Animations-Clips
- Keine abrupten Sprünge bei State-Wechseln
- Natürliches Aussehen beim Beschleunigen/Bremsen

---

## LateUpdate vs Update

Die Bridge läuft in **LateUpdate**, weil:
1. State Machine Update läuft in **Update** (HandleInput + OnUpdate)
2. Velocity-Berechnungen passieren während Update + TickSystem
3. LateUpdate garantiert, dass alle Werte des Frames final sind
4. Animator evaluiert nach LateUpdate (Unitys interner Ablauf)

```
Update()      → State Machine, Input, Velocity
LateUpdate()  → AnimatorParameterBridge (liest finale Werte)
               → Animator Evaluation (Unity intern)
```

---

## Verifikation

- [ ] `AnimatorParameterBridge.cs` kompiliert ohne Fehler
- [ ] Implementiert `IAnimationController`
- [ ] `[RequireComponent(typeof(Animator))]` vorhanden
- [ ] Speed wird normalisiert (horizontalSpeed / RunSpeed)
- [ ] Speed-Damping mit konfigurierbarem `_speedDampTime`
- [ ] IsGrounded wird direkt gesetzt (kein Damping)
- [ ] VerticalVelocity wird mit Damping gesetzt
- [ ] Jump/Land Trigger vorhanden
- [ ] HardLanding wird vor Land-Trigger gesetzt
- [ ] Ability Layer Weight steuerbar
- [ ] Läuft in LateUpdate

### Compiler prüfen

```bash
powershell -Command "Get-Content 'C:\Users\marcu\AppData\Local\Unity\Editor\Editor.log' -Tail 100 | Select-String -Pattern 'error|CS\d{4}'"
```

---

## Dateien nach diesem Schritt

```
Packages/Wiesenwischer.GameKit.CharacterController.Animation/
├── Runtime/
│   ├── Wiesenwischer.GameKit.CharacterController.Animation.Runtime.asmdef
│   └── Core/
│       ├── IAnimationController.cs          (aus Phase 1.4)
│       ├── AnimationParameters.cs           (erweitert in 2.2)
│       └── AnimatorParameterBridge.cs       (NEU)
├── Editor/
│   ├── AvatarMaskCreator.cs                 (aus 2.1)
│   └── AnimatorControllerCreator.cs         (aus 2.2, optional)
└── Resources/
    ├── AnimatorControllers/
    │   └── CharacterAnimatorController.controller
    ├── AvatarMasks/
    │   ├── Mask_UpperBody.mask
    │   ├── Mask_LowerBody.mask
    │   └── Mask_ArmsOnly.mask
    └── AnimationClips/
        └── ... (aus Phase 1)
```

---

## Phase 2 abgeschlossen!

Alle Animator-Komponenten sind konfiguriert:
- ✅ Avatar Masks für Layer-Trennung
- ✅ Animator Controller mit Layer-Struktur
- ✅ Locomotion Blend Tree (Idle → Walk → Run → Sprint)
- ✅ Airborne States mit Transitionen
- ✅ Parameter-Bridge für State Machine → Animator Sync

**Nächste Phase:** [Phase 3: Animation-Integration](../phase-3-animation-integration/README.md)
